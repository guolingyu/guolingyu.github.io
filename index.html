<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>郭大侠的BLOG</title>
  <meta name="author" content="郭大侠">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="郭大侠的BLOG"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="郭大侠的BLOG" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">郭大侠的BLOG</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-01-20T09:22:55.000Z"><a href="/2017/01/20/spring-cloud-eureka/">2017-01-20</a></time>
      
      
  
    <h1 class="title"><a href="/2017/01/20/spring-cloud-eureka/">Spring Cloud 微服务实战（2）- 用 Netflix Eureka 实现服务发现和注册</a></h1>
  

    </header>
    <div class="entry">
      
        <p>在调用微服务时，无论用什么办法，调用方需要知道服务方的 IP 和端口。如下图所示：</p>
<p><img src="http://ok09azpxo.bkt.clouddn.com/20160419111629615.png" alt="服务发现"></p>
<p>而 Eureka 就是负责管理一个服务方的 IP 和端口列表。它的工作流程如下：</p>
<p><img src="http://ok09azpxo.bkt.clouddn.com/eureka_architecture.png" alt="Eureka"></p>
<p>所有的服务方通过 Eureka Client 去跟 Eureka 服务器通讯，将自己的服务 IP 和端口进行注册，同时 Eureka Client 还具有一个心跳的逻辑，在注册后保持心跳。而服务的消费方通过跟 Eureka 服务器提供的 Rest API 获取到服务提供方的信息后，由消费方自行进行服务调用。Eureka Client 内部实现了一个简单的客户端负载均衡机制，可以通过 Round Robin 算法进行负载均衡。</p>
<h2 id="相比_ZooKeeper_的分析">相比 ZooKeeper 的分析</h2><p>讲到服务发现，就不得不提到 ZK，ZooKeeper 可以通过管理微服务各个服务提供方的 IP 和端口配置文件，和监听各个服务的状态来修正服务注册表。事实上，国内应用很广的 Dubbo 框架就使用了 ZooKeeper 来管理服务。 ZooKeeper 毋庸置疑是一个非常强大的应用，但是在微服务注册和发现上，它并不能算是一个好选择，理由包括：</p>
<ul>
<li>根据 CAP 定理(C- 数据一致性;A-服务可用性;P-服务对网络分区故障的容错性，这三个特性在任何分布式系统中不能同时满足，最多同时满足两个); ZooKeeper 是基于 CP 来构建的，即任何时刻对 ZooKeeper 的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性，但是它不能保证每次服务请求的可用性。这就导致在网络间歇性无法访问或者是出现网络分割问题时，ZooKeeper 将剔除所有节点并保证一致，同时返回一个空的服务列表给服务消费方，这甚至比返回一个5分钟以前的服务列表更让人无法接受。</li>
<li>维护 ZooKeeper 是一个非常复杂的工作，这些困难不仅仅包括 ZooKeeper 本身的集群运维复杂度，还包括所有服务调用方在写代码的时候都要遇到的 ZooKeeper 客户端和监听事件的编写上。</li>
</ul>
<h1 id="部署_Eureka_服务">部署 Eureka 服务</h1><p>Eureka 包括两个部分：</p>
<ul>
<li>Eureka Server 用于服务注册和发现</li>
<li>Eureka Client 同时用于服务提供方注册服务和服务消费方获取服务注册信息的 Eureka 客户端</li>
</ul>
<p>Eureka Server 比较简单，因为基本没啥可以配的，直接用官方的代码或者 docker 服务都可以，自己写一个就是几行注释的事情。<br>首先是 POM 里的设置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根Module里的预配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.4.3.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 根Module依赖管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-cloud-netflix<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.2.4.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="title">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="title">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 主要的配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 打包的配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后需要编写一个配置文件 application.yml。主要用于标示 Eureka 运行的端口号（也可以在运行时指定），同时也设置了将自己注册成服务的配置：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">server</span>:</span><br><span class="line">  port: <span class="number">8761</span></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  <span class="keyword">client</span>:</span><br><span class="line">    registerWithEureka: <span class="keyword">false</span></span><br><span class="line">    fetchRegistry: <span class="keyword">false</span></span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:$&#123;server.port&#125;/eureka/</span></span><br><span class="line">  <span class="keyword">server</span>:</span><br><span class="line">    waitTimeInMsWhenSyncEmpty: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>跟上一篇文章一样，mvn pakage 以后，运行 java -jar xxx.jar 后，可以在 8761 端口看到 Eureka 的 Web 界面：</p>
<p><img src="http://ok09azpxo.bkt.clouddn.com/20170122155653.png" alt="web界面"></p>
<p>目前还没有任何服务注册。之后试试看怎么注册一个服务上去。翻出上一篇文章里的代码，我们将 SampleController 里的服务注册成为一个可以调用的服务。</p>
<p>首先是在 POM 里加入运行时需要的依赖，上一个项目还只是一个 Spring Boot 项目</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根 Module 加入 Spring Cloud 的依赖管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-cloud-netflix<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.2.4.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="title">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="title">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- module 内加入依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>spring-cloud-netflix 是加入了 Spring Cloud 的基础配置，根据项目配置加入到根 module 中。</p>
<p>spring-cloud-starter-eureka 用于支持 Eureka 服务。包括添加 Eureka Client 的依赖。</p>
<p>然后在代码中加入注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SpringBootApplication</span></span><br><span class="line"><span class="annotation">@EnableAutoConfiguration</span></span><br><span class="line"><span class="annotation">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@EnableEurekaClient 表示启动 Eureka Client 并尝试进行服务注册。</p>
<p>之后需要在服务提供方的代码里，配置 Eureka 的服务器地址和端口，多谢一个 application.yml 进行配置</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server:</span></span><br><span class="line"><span class="label">  port:</span> <span class="number">8070</span></span><br><span class="line"><span class="string">spring:</span></span><br><span class="line"><span class="label">  application:</span></span><br><span class="line"><span class="label">    name:</span> server-<span class="number">01</span></span><br><span class="line"><span class="string">eureka:</span></span><br><span class="line"><span class="label">  client:</span></span><br><span class="line"><span class="label">    serviceUrl:</span></span><br><span class="line"><span class="label">      defaultZone:</span> <span class="string">http:</span><span class="comment">//localhost:8761/eureka/</span></span><br><span class="line"><span class="label">  instance:</span></span><br><span class="line"><span class="label">    metadataMap:</span></span><br><span class="line"><span class="label">      instanceId:</span> $&#123;spring.application.name&#125;:$&#123;spring.application.<span class="string">instance_id:</span>$&#123;random.value&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>server.port 表示服务的启动端口，可以是在运行时进行变更来启动多个实例</p>
<p>spring.application.name 表示服务的名字，同一个服务的多个实例，应该保证服务名称是一致的。否则会被作为两个服务。</p>
<p>eureka.client.serviceUrl.defaultZone 表示 Eureka Server 的地址，如果 Eureka Server 有多个，用逗号分隔。例如：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.client.serviceUrl.<span class="keyword">default</span>Zone=http://<span class="variable">&lt;peer1host&gt;</span>:<span class="variable">&lt;peer1port&gt;</span>/eureka,http://<span class="variable">&lt;peer2host&gt;</span>:<span class="variable">&lt;peer2port&gt;</span>/eureka</span><br></pre></td></tr></table></figure>
<p><code>instanceId</code> 表示eureka instance 标识，需要唯一，如果不配置，多个节点最终只会有一个生效。</p>
<p>配置好之后，通过 <code>java -jar xxx.jar</code> 运行可以在 Eureka 后台看到新增加的服务。</p>
<p>然后再通过运行 <code>java -Dserver.port=8071 -jar xxx.jar</code> 可以启动第二个实例，同时在 Eureka 后台可以看到服务的实例数变成了两个<br><img src="http://ok09azpxo.bkt.clouddn.com/20170122170108.png" alt="2个服务"></p>
<p>本文中的代码请参考 <a href="https://github.com/guolingyu/spring-cloud-demo/releases/tag/v1.1" target="_blank" rel="external">实例代码</a></p>
<p>下一篇文章将解释如何调用 Eureka 上注册的服务。 </p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-01-18T08:56:52.000Z"><a href="/2017/01/18/spring-cloud-boot/">2017-01-18</a></time>
      
      
  
    <h1 class="title"><a href="/2017/01/18/spring-cloud-boot/">Spring Cloud 微服务实战（1）- 从Spring Boot开始</a></h1>
  

    </header>
    <div class="entry">
      
        <p>最近微服务的概念可以说是在 Java 架构领域非常火，经常看到一些论坛或者网站组织人员交流微服务的架构经验学习活动。Spring Cloud 可以说是 Java 领域对于践行微服务概念的一个指导框架，基于尝鲜的习惯，我准备试用并记录一下实验的过程，只代表个人观点，欢迎指正。</p>
<p>首先是 Spring Cloud 作为微服务的治理框架，和国内老牌的分布式方案 Dubbo 相比，该怎么选型。老实说，在框架选择上我是有一些‘媚外’情节的。当然阿里近几年对于开源世界的贡献有目共睹，但是做开源纯粹只为绩效考核也是常有的事情，经常是考核以后就不维护了，所以在这两个里我选 Spring Cloud。当然我们还是可以从另外的角度比较</p>
<h3 id="1-涵盖的系统功能">1.涵盖的系统功能</h3><p>Dubbo 主要是服务调用，服务注册和发现，但是 Spring Cloud 比较全，还包括网关服务、分布式配置、消息总线、熔断器等。Dubbo 需要用其他开源项目来结合使用</p>
<h3 id="2-RPC_和_HTTP">2.RPC 和 HTTP</h3><p>Dubbo 虽然可以支持多种协议，不过从诞生开始，就是以 RPC 为主。RPC有传输效率较高的优点，但是也有一些劣势，包括：</p>
<ul>
<li>RPC的协议要求比较严，参数的加减都会影响服务</li>
<li>出现问题时要解决的难度比较大</li>
</ul>
<h2 id="从_Spring_Boot_开始">从 Spring Boot 开始</h2><p>如果要用 Spring Cloud，首先我们先试试 Spring Boot。Spring Boot 的作用在于创建和启动新的基于 Spring 框架的项目，并且项目内置 Tomcat 或者 jetty，可以通过 jar 包的方式运行。非常适合作为微服务的基础实现，跟容器服务整合更是轻松愉快。Spring Boot 包含的特性如下：</p>
<ul>
<li>创建可以独立运行的 Spring 应用</li>
<li>直接嵌入 Tomcat 或 Jetty 服务器，不需要部署 WAR 文件</li>
<li>提供推荐的基础 POM 文件来简化 Apache Maven 配置</li>
<li>尽可能的根据项目依赖来自动配置 Spring 框架，可以不适用 XML 文件</li>
</ul>
<p>从最简单的代码来展示一下 Spring Boot 的效果。首先创建一个基本的 maven 项目，然后看一下 POM：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.4.3.RELEASE<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><parent> 里配置的是项目的基础部分，如果 Spring Boot 只是一个 module，则这一段可以配置到项目的根 module 中，spring-boot-starter-parent 主要是包括了一些相关依赖库的版本配置，Java 代码版本等基础信息。建议使用。</parent></p>
<p>spring-boot-starter-web 是主要的依赖项。spring-boot-starter-web 默认使用 tomcat 来构建 web 运用。当使用 Maven 命令“mvn dependency:tree”来查看项目实际的依赖时，会发现其中包含了 Spring MVC 框架、SLF4J、Jackson、Hibernate Validator 和 Tomcat 等依赖。这实际上 Spring 推荐的 Web 应用中使用的开源库的组合。除了这个 POM 文件之外，Spring Boot 还提供了其他类似的 POM 文件。所有这些基础 POM 依赖都在“org.springframework.boot”组中。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>spring-boot-starter</td>
<td>核心 POM，包含自动配置支持、日志库和对 YAML 配置文件的支持。</td>
</tr>
<tr>
<td>spring-boot-starter-amqp</td>
<td>通过 spring-rabbit 支持 AMQP。</td>
</tr>
<tr>
<td>spring-boot-starter-aop</td>
<td>包含 spring-aop 和 AspectJ 来支持面向切面编程（AOP）。</td>
</tr>
<tr>
<td>spring-boot-starter-batch</td>
<td>支持 Spring Batch，包含 HSQLDB。</td>
</tr>
<tr>
<td>spring-boot-starter-data-jpa</td>
<td>包含 spring-data-jpa、spring-orm 和 Hibernate 来支持 JPA。</td>
</tr>
<tr>
<td>spring-boot-starter-data-mongodb</td>
<td>包含 spring-data-mongodb 来支持 MongoDB。</td>
</tr>
<tr>
<td>spring-boot-starter-data-rest</td>
<td>通过 spring-data-rest-webmvc 支持以 REST 方式暴露 Spring Data 仓库。</td>
</tr>
<tr>
<td>spring-boot-starter-jdbc</td>
<td>支持使用 JDBC 访问数据库。</td>
</tr>
<tr>
<td>spring-boot-starter-security</td>
<td>包含 spring-security。</td>
</tr>
<tr>
<td>spring-boot-starter-test</td>
<td>包含常用的测试所需的依赖，如 JUnit、Hamcrest、Mockito 和 spring-test 等。</td>
</tr>
<tr>
<td>spring-boot-starter-velocity</td>
<td>支持使用 Velocity 作为模板引擎。</td>
</tr>
<tr>
<td>spring-boot-starter-web</td>
<td>支持 Web 应用开发，包含 Tomcat 和 spring-mvc。</td>
</tr>
<tr>
<td>spring-boot-starter-websocket</td>
<td>支持使用 Tomcat 开发 WebSocket 应用。</td>
</tr>
<tr>
<td>spring-boot-starter-ws</td>
<td>支持 Spring Web Services。</td>
</tr>
<tr>
<td>spring-boot-starter-actuator</td>
<td>添加适用于生产环境的功能，如性能指标和监测等功能。</td>
</tr>
<tr>
<td>spring-boot-starter-remote-shell</td>
<td>添加远程 SSH 支持。</td>
</tr>
<tr>
<td>spring-boot-starter-jetty</td>
<td>使用 Jetty 而不是默认的 Tomcat 作为应用服务器。</td>
</tr>
<tr>
<td>spring-boot-starter-log4j</td>
<td>添加 Log4j 的支持。</td>
</tr>
<tr>
<td>spring-boot-starter-logging</td>
<td>使用 Spring Boot 默认的日志框架 Logback。</td>
</tr>
<tr>
<td>spring-boot-starter-tomcat</td>
<td>使用 Spring Boot 默认的 Tomcat 作为应用服务器。</td>
</tr>
</tbody>
</table>
<p>可以发现，Spring Boot 框架中，使用依赖来管理项目中使用到的库和配置，从而减少每次创建新的项目的开销，具有非常大的便捷性。</p>
<p>spring-boot-maven-plugin 用于将 Spring Boot 项目打包成可执行的 jar 包，使用 mvn package 命令打包后得到的 jar 包，可以直接使用 java -jar xxx.jar 的方式运行，可以说非常方便。</p>
<p>然后我们开始写两个类来实现基本的功能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="annotation">@ResponseBody</span></span><br><span class="line">    <span class="function">String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SampleController 是最基础的 SpringMVC 构件，由 @Controller 这样的注解来表示这个 API。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SpringBootApplication</span></span><br><span class="line"><span class="annotation">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在另一个 Application 类中，出现了两个 Spring Boot 新出的注解形式：</p>
<p>@SpringBootApplication 表示这是一个 SpringBoot 的 Application 程序，使用该程序的类，会作为整个工程的启动类，并以 main 函数开始运行。通过刚才提到的 maven 插件 spring-boot-maven-plugin 配置成为整个 jar 包的启动类。 而 main 函数中，应该使用 SpringApplication.run() 这个方法来启动运行整个 web 容器。</p>
<p>@EnableAutoConfiguration 是 Spring Boot 的另外一个革新点，这是一个可以自动完成 Spring 配置框架的功能，从而省略掉以往的 application-xxx.xml 这样的配置文件。 实现自动配置主要是靠项目的依赖项来实现，在刚才配置的POM文件里，Spring Boot 通过 spring-boot-starter-web 来识别项目应该是一个 Tomcat 和 SpringMVC 的项目，所以 Spring 启动了一个 Tomcat 并尝试自动配置相关的 XML 等配置。</p>
<p>之后通过使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar target/xxx.jar</span><br></pre></td></tr></table></figure></p>
<p>之后可以顺利访问启动的服务了。更多的可以参考<br><a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/" target="_blank" rel="external">Spring Boot Reference Guide</a></p>
<p>代码请参考<br><a href="https://github.com/guolingyu/spring-cloud-demo/tree/v1.0" target="_blank" rel="external">代码参考</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-27T08:04:44.000Z"><a href="/2015/11/27/git-branch-management/">2015-11-27</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/27/git-branch-management/">开发流程和分支管理</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="简介">简介</h1><p>  这是我们团队自己定的开发流程和 Git 分支规范。其实在开发流程中，并没有一个最好的规范或者说实践，但是因为开发涉及到团队协作，因此必须有一些规范才能让合作更加默契。</p>
<h1 id="管理工具">管理工具</h1><p>  我们团队使用 Git 工具来管理代码、发布和持续集成,也用来管理部分项目私密的文档。<br>  关于 Git 的基础知识，可以参考：</p>
<ul>
<li><a href="https://guides.github.com/" target="_blank" rel="external">GitHub 的教程</a></li>
<li><p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的Git教程</a></p>
<p>代码主要放在 <a href="https://github.com/aotumanlady" target="_blank" rel="external">GitHub</a> 上。我们并不限制开发人员使用特定的 Git 工具，但是我们仍然建议开发人员使用 Shell（命令行） 或者 <a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">SourceTree</a>（图形工具）来管理代码。  </p>
</li>
</ul>
<h1 id="加入组织">加入组织</h1><p>  我们在 GitHub 上建立了一个叫做 aotumanlady 的组，首先需要将自己的 GitHub 账号告知管理员，由管理员发送邀请，然后访问 <a href="https://github.com/aotumanlady" target="_blank" rel="external">aotumanlady 的主页</a> 就可以接受邀请并加入了。</p>
<h1 id="添加工程">添加工程</h1><p>  加入组织后，就可以看到组织的 repository 了。之后开发人员需要按照 GitHub 的流程来参与项目的开发，步骤如下：</p>
<ol>
<li>Fork 组织的 Repository</li>
<li>新开一个 Branch，开发项目的功能代码</li>
<li>开发完成后，合并到 develop 分支，然后提交 Pull Request 给项目的负责人</li>
<li>负责人需要对 PR 的代码进行 Code Review， 不合格的代码需要修改， 修改合格以后 Merge 到主 repository 中</li>
<li>在 develop 版本中进行测试</li>
<li>测试完成后，合并到 master 分支，然后打 Tag 发布</li>
</ol>
<h1 id="Branch_和_Tag">Branch 和 Tag</h1><h2 id="Branch">Branch</h2><p>  在组织的项目中，通常都包括两个 branch：master 和 develop，<br>  master 是正常的用于发布的代码，这个分支应该基本稳定，并保持整洁<br>  develop 是主要的开发分支，包括最新的代码，也是所有的人完成一个版本后，进行 merge 的原代码<br>  假如开发人员要开发一个功能，应该首先在自己的工程的 develop 分支中，开一个新的分支，分知名可以是 function1， 然后进行开发，开发完成后，合并到自己工程的 develop 分支里，然后提交 develop 分支的 Pull Request。</p>
<h2 id="Tag">Tag</h2><p>  对应每个发布版本的 tag。SDK 和应用程序的 tag 遵照 &lt;major&gt;.&lt;minor&gt;.&lt;patch&gt; 的命名，如 2.5.1</p>
<h1 id="发布新版本流程">发布新版本流程</h1><ol>
<li>首先确认所有的开发代码都已经合并到组织的 Repository 里的 develop 分支</li>
<li>然后对 develop 分支进行测试</li>
<li>测试成功以后，将 develop 分支合并到 master 分支</li>
<li>在 master 分支上建立对应版本的 tag， 利用持续集成工具上线</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-24T08:45:43.000Z"><a href="/2015/11/24/dev-tool-prepare/">2015-11-24</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/24/dev-tool-prepare/">技术团队的开发设备</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="简介">简介</h1><p>我们相信对于技术人员来说，一个更为优秀的开发设备能够帮助技术人员更好的完成工作。我们也致力于尽可能提供给所有开发人员一个好用的开发设备和理想的开发环境。所以在考虑给技术团队配备开发设备的时候，我们主要考虑了如下问题：</p>
<ol>
<li>什么样的开发设备是开发人员最熟悉和喜欢的</li>
<li>我们希望开发人员使用什么样的设备和操作系统</li>
<li>我们能够提供给开发人员多少经费帮助开发人员购买他们喜爱的设备</li>
</ol>
<p>因此我们把自己能够提供的补贴标准清晰的公布出来，我们相信开诚布公能够帮助新同事理解和认识我们。</p>
<blockquote>
<p>补贴的标准会随着公司不断发展而变化，希望大家理解</p>
</blockquote>
<h1 id="鼓励开发人员携带自己的电脑">鼓励开发人员携带自己的电脑</h1><p>首先，我们鼓励开发人员自己携带自己喜欢的笔记本电脑办公，它可以是一台来自 Apple 的 Macbook Pro，也可以是一台性能强悍的 Alienware，当然它最好是一台笔记本电脑，这样可以更好的把来不及完成的工作带回家。</p>
<p>之所以鼓励开发人员自带电脑，主要原因包括：</p>
<ul>
<li>自己的电脑用起来最顺手，开发效率也最高</li>
<li>既能节省公司成本，也能满足个人性化要求</li>
</ul>
<p>对于自己携带了笔记本的开发同事，我们会征求他的意见给他配备其他需要的设备，例如显示器、鼠标、键盘等。同时我们会在入职后的头一年里提供每个月 300 元补助用于补贴自带电脑的开发人员。</p>
<h1 id="为所有没有自己电脑的开发同事配备笔记本电脑">为所有没有自己电脑的开发同事配备笔记本电脑</h1><p>对于自己没有电脑或者只拥有台式机的同事，我们会为他配备笔记本电脑。</p>
<p>所配的电脑在员工离职时需要归还。</p>
<h1 id="为所有开发同事配备_23_寸显示器">为所有开发同事配备 23 寸显示器</h1><p>为了满足浏览代码的习惯，我们为所有开发同事配备23寸显示器。</p>
<p>所配的显示器在员工离职时需要归还。</p>
<h1 id="推荐开发人员使用_Macbook_进行开发">推荐开发人员使用 Macbook 进行开发</h1><p>我们推荐开发人员购买 Macbook 用于开发，主要原因包括：</p>
<ul>
<li>Mac 是基于 UNIX 系统的，跟服务器环境非常类似，拥有完整的 Shell 环境，能够培养开发人员对于 UNIX 和命令行的熟练程度</li>
<li>Mac 上拥有最好用的开发工具和开发环境，在 Mac 上安装 Node、git、Java、C、C++、MySQL、Nginx 都非常容易，能够很好的帮助开发人员快速开发</li>
<li>Mac 上没有那么多的流氓软件影响系统流畅程度，同时也保证了关键的数据和代码不至于被恶意窃取</li>
<li>Mac 上没有那么多的游戏（笑~~）</li>
</ul>
<p>对于入职后不选择我们提供的笔记本电脑而选择自行购买 Macbook 的开发同事，我们提供 4000 元补助可用于 Macbook 的购买开销。请注意：发票抬头必须是「北京春风十里科技有限公司」，发票内容必须是所购商品明细。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-24T07:36:55.000Z"><a href="/2015/11/24/how-to-be-cto/">2015-11-24</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/24/how-to-be-cto/">创业公司的 CTO 该干什么</a></h1>
  

    </header>
    <div class="entry">
      
        <p>之前的一段创业经历中，我作为联合创始人和 CTO，一直在跟 CEO 辩论什么样的产品方向才是最适合的产品方向，这样的辩论持续了很久，其实这样的经历对于创业公司非常危险，因为创始人都不清楚方向，也缺少相应的判断力什么时候要换方向。现在又加入了一个新的项目，在这段时间里，可以回想一下，一个创业公司的 CTO 该干什么呢。</p>
<p>首先我并不是一个专业的 CTO，更不是一个有成功经验的合伙人（都是人生淫家了，谁有空写博客）。所以只有靠自己想，首先推荐一个知乎上的答案</p>
<blockquote>
<p><a href="http://www.zhihu.com/question/31753374" target="_blank" rel="external">从大公司离职去小公司当 CTO 是一种怎样的体验？</a></p>
</blockquote>
<p>那么自己考虑下自己该干啥</p>
<h1 id="首先组建技术团队">首先组建技术团队</h1><p>光棍 CTO 屁都不是，当然类似扎克伯格那种从头到尾都自己写下来的大牛我可比不了，中国的互联网竞争也是极其激烈，不止勤奋，也习惯抄袭，自己慢慢码不如利用集团军优势先碾压对手，到时候比对手早上线早融资3个月就是胜利。所以 CTO 第一件事就是求爷爷告奶奶找之前的同事让人加入啊，什么期权啊，高薪啊，总之就是 CEO 忽悠别人干的那些事你也得干啊，当然靠谱的人得表现的有诚意，该给的要大方，能省的也得省。毕竟算是自家生意，不能浪费。</p>
<h1 id="然后是告诉合伙人怎么做产品">然后是告诉合伙人怎么做产品</h1><p>大部分创业公司的 CEO 和合伙人团队可能都不是技术或者产品出身，对于产品研发流程不了解。他们最大的愿望可能就是「这个 APP 看起来很简单，能不能下个月就上线呢？」</p>
<p>所以 CTO 首先要把自己的经验带给团队，一个合理的产品开发流程和周期是怎么样的，一个好的 APP 不是变魔术，不会「duang」的一下就出现在 AppStore 的排行榜榜首，带给公司千万级别的用户迈向人生巅峰。产品是经过设计-开发-测试-上线-运营-迭代一步一步丰富起来的，CTO 首先要把客观理性和严谨验证的思路带给团队，并且规划出产品上线的步骤和路径。</p>
<p>一个优秀的 CTO，应该能够预知产品的功能点和受欢迎的程度，并且对于团队的路线进行有效的规划。</p>
<h1 id="要建立技术团队的氛围">要建立技术团队的氛围</h1><p>公司初创时的技术氛围是影响整个公司技术高度的一个重要因素，对于创业公司来说，需要：</p>
<ul>
<li>极客氛围，每个人都自我驱动，做好产品的每一个点，丝毫不能马虎，任何错误都要严格批评</li>
<li>快速成长，创业公司的技术人员往往都是一个顶两，就算不要求每个人都是全栈工程师，至少也能独当一面</li>
</ul>
<p>同时要注意培养技术团队的情商，不仅要培养技术实力，也要培养合作精神。对于生活不能自理或者无法跟人沟通的大牛我也是敬谢不敏，您还是去狼厂看看把。</p>
<h1 id="大部分时间还是要撸代码的">大部分时间还是要撸代码的</h1><p>关于 CTO 写不写代码这个事情嘛，我觉得肯定是要写的，且不说招聘的时候不可能一帆风顺，本来就是一个人顶两个人用的创业公司里，谁都要上阵写代码，再加上 IT 行业变化这么快，不写代码一下子就 OUT 掉了。</p>
<blockquote>
<p>不写代码的 CTO 跟咸鱼有什么区别。</p>
</blockquote>
<p>而且有些职位确实很难招聘，比如 iOS（当然我相信过几年肯定很多,不过现在确实很难找），所以如果有必要，CTO 也要从自己擅长的领域走出来去做一个多面手。</p>
<h1 id="有时候还要运维">有时候还要运维</h1><p>CTO 一开始要管服务器运维的，当然现在云服务比较多，运维的工作量就下来了，反正钱能解决的事情就不是事。什么阿里云，又拍云，七牛啥的，能用就用把，一开始能省下不少时间去管这些。 </p>
<p>CTO 主要的精力应该是保证服务器环境的安全稳定。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-24T05:04:39.000Z"><a href="/2015/11/24/restart-a-job/">2015-11-24</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/24/restart-a-job/">每次离职都是新的开始</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="在网易">在网易</h2><p>其实我在网易一直是幸运的，从一开始就负责了网易跟贴项目。当时从爱立信出来的我对互联网技术并不了解，而网易跟贴是网易的老项目了，项目已经做了很多年，积攒了大把的口碑。从以前的「无跟贴，不新闻」到后来的网易「有态度」年终策划，跟贴都是网易UGC的核心产品，当时的网易跟贴只有2个开发人员，经常出问题，但是对于我来说是个特别好的锻炼机会。由于项目问题比较多，领导也很重视，所以有了对老项目大改的机会，基本上架构换过好几遍，包括 MySQL 到 Oracle （老丁为了WOW买了 Oracle 的不限量自由使用权），从静态 HTML 缓存到 Lua+Redis 内存缓存，在跟贴项目这段遇到问题就折腾的经历，基本上塑造了我之后「实用」+「快速」的技术路线，讲究的就是一切从实际出发，不盲目使用新技术，快速完成和快速检验效果，多次迭代，达成最好的用户体验为主。中间发生了一段小插曲，有一个在特别早期加入陌陌的机会，可惜当初没有想好自己的未来，对创业没准备好，所以放弃了，当然后来陌陌高歌猛进，一帆风顺前往美国敲钟，也是深以为憾，想必这事也导致我后来一直在寻找一个创业和突破的机会吧。</p>
<p>负责了一段时间的跟贴以后，因为网易论坛技术负责人离职，我又负责了论坛的技术开发工作，网易论坛是一个坑型的项目，项目结构老，变化慢，没法动大刀子，只好维护住，所幸没有出大问题。后来又负责了网易微博，还顺利升了经理。但是当时新浪微博已经俨然是第一了。网易微博虽说挂了重点项目的头衔，但是在对手的竞争压力下颓势尽显无可挽回，技术团队的一部分被拉去做花田，局面很不乐观，所幸网易微博班底还在，在部分技术上仍然有亮点，包括搜索、推荐等基础技术。在各种技术条件具备的基础上，以完善各个子项目，在已有技术上发掘可用性，创造可能性是当时的主要工作。</p>
<p>在跟贴、论坛和微博都稳定发展的基础上，我跟当然的产品技术中心领导夏天宇说我想做新项目，从新项目中找可能。所以把项目组定位到新项目研发中。在UGC积累的大量技术经验，在做新项目时是新车熟路的，做了包括真话，自由行，海外房产等项目，可惜大部分项目并没有运营起来。</p>
<p>在网易最后也是最成功的项目是网易BoBo，当时是网易总编辑赵莹发起的项目，主要是做娱乐直播，就是一大波大胸妹子在网上唱歌瞎侃的直播项目。项目启动时并不被看好，认为是违背了网易精神，并且有相当的内容跨度，不容易在网易运营成功。不过当时我觉得这项目模式成熟，内容可控，为此也准备了当时组里几乎全部的精兵强将，项目按时上线，并且在赵总的扶持下顺利完成收入和口碑的双重指标，网易BoBo被丁磊提拔为一级事业部，基本上升技术总监也是板上钉钉的事情，但是在网易深深的遗憾其实一直困扰着我，这么多年的积累和锻炼，总想做点什么去丰富自己的人生。所以我离职了，离职前，给跟着我的兄弟们升职和加薪了。</p>
<h2 id="创业">创业</h2><p>从网易走的时候，其实我并不清楚自己要干啥，「互联网+」和「全民创业」几乎人人挂在嘴边，初创公司的估值也异乎寻常的高，在五道口聊过几个项目以后，我就加入了一个在「36Kr」孵化的项目，当时几乎没怎么考虑，但是事情开始之后，发展并不顺利，初期的想法太理想，难以落地发展，用户认可度非常低。折腾了一年，最后还是决定放弃走人。</p>
<h2 id="重新开始">重新开始</h2><p>在网易新闻客户端负责运营的龙志是我负责UGC技术团队时的老熟人了，总编辑陈峰离职以后，移动部门基本被拆散了，龙志也带着他的团队走向了创业的道路。跟龙志聊了两次，倒是也算投缘，加上项目团队还靠谱，所以就重新开始新的创业项目。</p>
<p>所有上面的这些，其实都是废话，自己一个人怀念一下当初的历程，不希望得到理解也不需要。坐在望京民居里的新租的办公室，只是觉得这么多年的经历仿佛都很虚幻，人生的一个10年就这么过去了，之后10年是新的开始，不管怎么样，没有后悔。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜尋">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">標籤</h3>
  <ul class="entry">
  
    <li><a href="/tags/Spring-Cloud/">Spring-Cloud</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 郭大侠
  
</div>
<div class="clearfix"></div></footer>
  <script src="http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>